<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileWatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Parameters for Java</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.params4j.impl</a> &gt; <span class="el_source">FileWatcher.java</span></div><h1>FileWatcher.java</h1><pre class="source lang-java linenums">/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package uk.co.spudsoft.params4j.impl;

import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;

/**
 * A convenience class for performing file watches on multiple dirs with a delay after each change to allow batches of changes to complete before being processed.
 * 
 * Changes to files often come in multiple operations and a quick file watcher can end up either performing unnecessary processing or processing inconsistent files.
 * To avoid this FileWatcher introduces a small delay (2s) after any file notifications before processing the change - if another change comes in during the delay the timer
 * restarts - files have to be stable for 2s.
 * 
 * @author jtalbut
 */
public class FileWatcher {
  
<span class="fc" id="L34">  private static final Logger logger = LoggerFactory.getLogger(FileWatcher.class);</span>

  private static final int NOTIFICATION_DELAY_S = 2;
  private static final int DEFAULT_DELAY_S = 3600;
  
<span class="fc" id="L39">  private final AtomicReference&lt;Thread&gt; threadRef = new AtomicReference&lt;&gt;();</span>
  private final WatchService watcher;
  private final Runnable callback;
<span class="fc" id="L42">  private Map&lt;Path, WatchKey&gt; watchKeys = new HashMap&lt;&gt;();</span>

  /**
   * Constructor.
   * @param callback The Runnable that will be called when any of the watched paths have changed and the changes have stabilized.
   */
<span class="fc" id="L48">  public FileWatcher(Runnable callback) {</span>
<span class="fc" id="L49">    WatchService tempWatchService = null;</span>
    try {
<span class="fc" id="L51">      tempWatchService = FileSystems.getDefault().newWatchService();</span>
<span class="nc" id="L52">    } catch (IOException ex) {</span>
<span class="nc" id="L53">      logger.error(&quot;Failed to create watch service, configuration changes will not be noticed: &quot;, ex);              </span>
<span class="fc" id="L54">    }</span>
<span class="fc" id="L55">    this.watcher = tempWatchService;</span>
<span class="fc" id="L56">    this.callback = callback;</span>
<span class="fc" id="L57">  }</span>

  /**
   * Add a path to the list of paths being watched.
   * @param path The path to add to the list of watched paths.
   * @throws IOException if something goes wrong.
   */
  public void watch(Path path) throws IOException {
<span class="pc bpc" id="L65" title="1 of 4 branches missed.">    if (watcher != null &amp;&amp; !watchKeys.containsKey(path)) {</span>
<span class="fc" id="L66">      WatchKey key = path.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);</span>
<span class="fc" id="L67">      watchKeys.put(path, key);</span>
    }
<span class="fc" id="L69">  }</span>

  /**
   * Start monitoring files.
   * 
   * Do not call this method more than once - it will create multiple threads that do the same thing.
   * 
   * Monitoring will only begin if at least one watch path has been set to watch.
   * 
   * @return true if monitoring started.
   */
  public boolean start() {
<span class="fc bfc" id="L81" title="All 2 branches covered.">    if (!watchKeys.isEmpty()) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">      if (threadRef.get() == null) {</span>
<span class="fc" id="L83">        Thread thread = new Thread(this::eventLoop, &quot;Params4JFileWatcher&quot;);</span>
<span class="fc" id="L84">        Thread oldThread = threadRef.compareAndExchange(null, thread);</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        if (oldThread == null) {</span>
<span class="fc" id="L86">          thread.start();</span>
        }
      }
<span class="fc" id="L89">      return true;</span>
    } else {
<span class="fc" id="L91">      return false;</span>
    }
  }

  private void eventLoop() {

<span class="fc" id="L97">    int pollDelay = DEFAULT_DELAY_S;</span>
    
    /**
     * This loop has two non-standard features:
     * 1. It doesn't care what has changed, the caller will run a full gather afterwards so it doesn't matter.
     * 2. It waits as bit after a filesystem notification before notifying the client to allow batches of notifications to complete.
     */
    while (true) {

      // Wait for key to be signaled
      WatchKey key;
      try {
<span class="fc" id="L109">        key = watcher.poll(pollDelay, TimeUnit.SECONDS);</span>
<span class="nc" id="L110">      } catch (InterruptedException x) {</span>
<span class="nc" id="L111">        return;</span>
<span class="fc" id="L112">      }</span>
      
      // There are now three possibilities:
      // 1. A new notification has come in.
      //    key != null -&gt; set pollDelay to NOTIFICATION_DELAY_S.
      // 2. The timeout has been hit for no useful reason.
      //    key == null &amp;&amp; pollDelay != NOTIFICATION_DELAY_S -&gt; spin round
      // 3. The timeout has been hit after the post-notification delay.
      //    key == null &amp;&amp; pollDelay == NOTIFICATION_DELAY_S -&gt; notify and set pollDelay to default
<span class="fc" id="L121">      logger.trace(&quot;Poll completed, key: {}, pollDelay: {}&quot;, key, pollDelay);</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">      if (key == null) {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (NOTIFICATION_DELAY_S == pollDelay) {</span>
<span class="fc" id="L125">          callback.run();</span>
<span class="fc" id="L126">          pollDelay = DEFAULT_DELAY_S;</span>
        }
      } else {
        // Drain the events, but don't care what they are (they can't all be OVERFLOW)
<span class="fc" id="L130">        key.pollEvents();</span>
<span class="fc" id="L131">        pollDelay = NOTIFICATION_DELAY_S;</span>
<span class="fc" id="L132">        key.reset();</span>
      }
<span class="fc" id="L134">    }</span>

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>