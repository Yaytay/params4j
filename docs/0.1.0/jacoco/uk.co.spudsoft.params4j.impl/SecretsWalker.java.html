<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecretsWalker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Parameters for Java</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.params4j.impl</a> &gt; <span class="el_source">SecretsWalker.java</span></div><h1>SecretsWalker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 jtalbut
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package uk.co.spudsoft.params4j.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * FileVisitor used by SecretsGatherer to construct a JSON ObjectNode containing files from the root directory.
 * @author jtalbut
 */
public class SecretsWalker extends SimpleFileVisitor&lt;Path&gt; {

<span class="fc" id="L41">  private static final Logger logger = LoggerFactory.getLogger(SecretsWalker.class);</span>

  private final Path root;
  private final ObjectMapper objectMapper;
  private final long fileSizeLimit;
  private final int fileCountLimit;
  private final Charset charset;
  private final Consumer&lt;Path&gt; dirHandler;

  private final ObjectNode objectNode;
<span class="fc" id="L51">  private final Map&lt;Path, ObjectNode&gt; nodes = new HashMap&lt;&gt;();</span>
  private ObjectNode current;
  private int fileCount;

  /**
   * Constructor.
   * @param root The base path from which to start searching, typically something like &quot;/etc/[service name]/conf.d&quot;
   * @param objectMapper The ObjectMapper to use to build the resulting ObjectNode.
   * @param fileSizeLimit The maximum size of file to attempt to load.
   * The recommendation is to set this to slightly larger than your standard secret length.
   * @param fileCountLimit The maximum number of files to attempt to load.
   * The recommendation is to set this to one more than the number of secrets in your parameters hierarchy.
   * @param charset The charset to use when reading the file.
   * @param dirHandler Optional consumer called for each directory that is entered.
   */
  @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;Externable objects are mutable&quot;)
<span class="fc" id="L67">  public SecretsWalker(Path root, ObjectMapper objectMapper, int fileSizeLimit, int fileCountLimit, Charset charset, Consumer&lt;Path&gt; dirHandler) {</span>
<span class="fc" id="L68">    this.root = root;</span>
<span class="fc" id="L69">    this.objectMapper = objectMapper;</span>
<span class="fc" id="L70">    this.objectNode = objectMapper.createObjectNode();</span>
<span class="fc" id="L71">    this.current = this.objectNode;</span>
<span class="fc" id="L72">    this.fileSizeLimit = fileSizeLimit;</span>
<span class="fc" id="L73">    this.fileCountLimit = fileCountLimit;</span>
<span class="fc" id="L74">    this.charset = charset;</span>
<span class="fc" id="L75">    this.dirHandler = dirHandler;</span>
<span class="fc" id="L76">  }</span>

  /**
   * Get the ObjectNode that reflects the directory/file structure underneath the root path.
   * @return the ObjectNode constructed by walking the file tree.
   */
  @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;Externable object is mutable&quot;)
  public ObjectNode getObjectNode() {
<span class="fc" id="L84">    return objectNode;</span>
  }

  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
<span class="fc" id="L89">    logger.trace(&quot;Leaving dir: {}&quot;, dir);</span>
<span class="fc" id="L90">    current = nodes.get(dir);</span>
<span class="fc" id="L91">    return FileVisitResult.CONTINUE;</span>
  }

  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
<span class="fc" id="L96">    logger.trace(&quot;File: {}&quot;, file);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">    if (attrs.isDirectory()) {</span>
<span class="fc" id="L98">      logger.trace(&quot;Ignoring file {} because it is a directory (can be caused by max depth being exceeded)&quot;, file);</span>
    } else {
<span class="fc" id="L100">      Path pathFileName = file.getFileName();</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">      if (pathFileName != null) {</span>
<span class="fc" id="L102">        String filename = pathFileName.toString();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (filename.startsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L104">          logger.trace(&quot;Ignoring file {} because it is hidden&quot;, file);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        } else if (attrs.size() &gt; fileSizeLimit) {</span>
<span class="fc" id="L106">          logger.trace(&quot;Ignoring file {} because it is larger than the maximum size ({} &gt; {})&quot;, file, attrs.size(), fileSizeLimit);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        } else if (++fileCount &gt; fileCountLimit) {</span>
<span class="nc" id="L108">          logger.trace(&quot;Ignoring file {} because too many files have been processed ({} &gt; {})&quot;, file, fileCount, fileCountLimit);</span>
        } else {
<span class="fc" id="L110">          try (FileInputStream fis = new FileInputStream(file.toFile())) {</span>
<span class="fc" id="L111">            String value = new String(fis.readAllBytes(), charset);</span>
<span class="fc" id="L112">            current.put(filename, value);</span>
<span class="nc" id="L113">          } catch (Throwable ex) {</span>
<span class="nc" id="L114">            logger.trace(&quot;Ignoring file {} because it could not be read: &quot;, file, ex);</span>
<span class="fc" id="L115">          }</span>
        }
      }
    }
<span class="fc" id="L119">    return FileVisitResult.CONTINUE;</span>
  }

  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {    
<span class="fc" id="L124">    Path pathFileName = dir.getFileName();</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">    if (pathFileName != null) {</span>
<span class="fc" id="L126">      String dirname = pathFileName.toString();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">      if (dir.equals(root)) {</span>
<span class="fc" id="L128">        return FileVisitResult.CONTINUE;</span>
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">      } else if (dirname.startsWith(&quot;.&quot;) || dir.equals(root)) {</span>
<span class="fc" id="L130">        logger.trace(&quot;Ignoring dir {} because it is hidden&quot;, dir);</span>
<span class="fc" id="L131">        return FileVisitResult.SKIP_SUBTREE;</span>
      } else {
<span class="fc" id="L133">        logger.trace(&quot;Entering dir: {}&quot;, dir);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (dirHandler != null) {</span>
<span class="fc" id="L135">          dirHandler.accept(dir);</span>
        }
<span class="fc" id="L137">        ObjectNode dirNode = objectMapper.createObjectNode();</span>
<span class="fc" id="L138">        current.set(dirname, dirNode);</span>
<span class="fc" id="L139">        nodes.put(dir, current);</span>
<span class="fc" id="L140">        current = dirNode;</span>
<span class="fc" id="L141">        return FileVisitResult.CONTINUE;</span>
      }
    } else {
<span class="nc" id="L144">      return FileVisitResult.TERMINATE;</span>
    }
  }

  @Override
  public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
<span class="nc" id="L150">    logger.trace(&quot;Failed to visit: {}&quot;, file);</span>
<span class="nc" id="L151">    return FileVisitResult.CONTINUE;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>